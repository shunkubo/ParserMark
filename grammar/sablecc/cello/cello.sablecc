Package org.cello;

Helpers
unicode_input_character = [0..0xffff];
ht  = 0x0009;
lf  = 0x000a;
ff  = 0x000c;
cr  = 0x000d;
sp  = ' ';

not_star = [unicode_input_character - '*'];
not_star_not_slash = [unicode_input_character - ['*' + '/']];

java_letter = ['a'..'z']| ['A'..'Z'] | '$' | '_';
java_letter_or_digit = ['a'..'z']| ['A'..'Z'] | ['0'..'9'] | '$' | '_';

line_terminator = lf | cr | cr lf;
input_character = [unicode_input_character - [cr + lf]];

white_space = (sp | ht | ff | line_terminator);

traditional_comment = '/*' not_star* ('*' (not_star_not_slash not_star*)?)* '*/';

end_of_line_comment = '//' input_character* line_terminator?;

underscores = '_'+;

non_zero_digit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
digit = '0' | non_zero_digit;
digit_or_underscore = digit | '_';
digits_and_underscores = digit_or_underscore+;
digits = digit | digit digits_and_underscores? digit;
decimal_numeral = '0' | non_zero_digit digits? | non_zero_digit underscores digits;

integer_type_suffix = 'l' | 'L';

decimal_integer_literal = decimal_numeral integer_type_suffix?;

single_character = [input_character - [''' + '\']];
escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\';
string_character = [input_character - ['"' + '\']] | escape_sequence;
identifier = java_letter java_letter_or_digit*;



Tokens

comment = traditional_comment | end_of_line_comment;
white_spaces = white_space+ ;

boolean = 'boolean';
colon  = 'colon';
else   = 'else';
if     = 'if';
if1     = 'if1';
if2     = 'if2';
if3     = 'if3';
if4     = 'if4';
if5     = 'if5';
if6     = 'if6';
if7     = 'if7';
if8     = 'if8';
if9     = 'if9';
if_a     = 'ifA';
if_b     = 'ifB';
import = 'import';
int    = 'int';
long   = 'long';
dummy_token1 = 'dummy1';
dummy_token2 = 'dummy2';
question = '?';
return = 'return';

period = '.';
comma = ',';
semi  = ';';
ex    = '!';
dot   = '...';
left_paren = '(';
right_paren = ')';
left_braces = '{';
right_braces = '}';
assign  = '=' ;
star_assign = '*=';
slash_assign = '/=';
percent_assign = '%=';
plus_assign = '+=';
minus_assign = '-=';
sh_left = '<<=';
sh_right = '>>=';
u_sh = '>>>=';
and_assign = '&=';
caret_assign ='^=';
bar_assign = '|=';
bar_bar = '||';
amp_amp = '&&';
equal   = '==';
n_equal = '!=';
less_than = '<';
greater_than = '>';
less_than_eq = '<=';
greater_than_eq = '>=';
colon_colon = '::';

integer_literal = decimal_integer_literal;
boolean_literal = 'true' | 'false';
character_literal = ''' single_character ''' | ''' escape_sequence ''';
string_literal = '"' string_character* '"';
null_literal = 'null';

Ignored Tokens
white_spaces, comment;


Productions
file = import_declaration* top_level+ ;
top_level = declaration semi ;
import_declaration = import identifier identifier_repeat* semi ;
identifier_repeat = period identifier_repeat ;
declaration       = {method} method_declaration
                  | {variable} variable_declaration
                  | {dummy1} dummy1
                  | {dummy2} dummy2
                  ;
method_declaration = type identifier left_paren method_param_list right_paren block_semi;
black_semi        = {block} block
                  | {semi} semi ;
method_param_list    = param_list_option? comma_or_dot? ;
param_list_option    = method_param param_list_repeat* ;
param_list_repeat    = comma method_param ;
comma_or_dot         = comma dot ;
method_param         = type identifier? ;
variable_declaration = type variable_list semi ;
variable_list        = init_decl init_decl_repeat* ;
init_decl_repeat     = comma init_decl ;
init_decl            = identifier initial_option? ;
initial_option       = assign initializer ;
initializer          = assignment_expression ;
dummy1               = dummy_token1 variable_list semi ;
dummy2               = dummy_token2 variable_list semi ;

type           = {primitive} primitive_type
                | {reference} reference_type;
primitive_type = {int} int
                | {boolean} boolean
                | {long} long
                ;
reference_type = identifier ;

block     = left_braces block_alter right_braces ;
block_alter = {statement} statement
            | {declaration} declaration
            ;

statement = {block} block
          | {if} if left_paren expression right_paren block else_option?
          | {if1} if1 left_paren expression right_paren block else_option?
          | {if2} if2 left_paren expression right_paren block else_option?
          | {if3} if3 left_paren expression right_paren block else_option?
          | {if4} if4 left_paren expression right_paren block else_option?
          | {if5} if5 left_paren expression right_paren block else_option?
          | {if6} if6 left_paren expression right_paren block else_option?
          | {if7} if7 left_paren expression right_paren block else_option?
          | {if8} if8 left_paren expression right_paren block else_option?
          | {if9} if9 left_paren expression right_paren block else_option?
          | {ifa} if_a left_paren expression right_paren block else_option?
          | {ifb} if_b left_paren expression right_paren block else_option?
          | {return} return expression? semi
          | {expression} expression semi
          | {semi} semi
          ;
else_option = else block ;

expression            = assignment_expression assignment_ex_repeat* ;
assignment_ex_repeat  = comma assignment_expression ;
assignment_expression = {unary} unary_assignment
                        | {conditional} conditional_expression
                        ;
unary_assignment      = unary_expression assignment_operator assignment_expression;

assignment_operator   = {assign} assign
                       | {star} star_assign
                       | {slash} slash_assign
                       | {percent} percent_assign
                       | {plus} plus_assign
                       | {minus} minus_assign
                       | {shl} sh_left
                       | {shr} sh_right
                       | {ush} u_sh
                       | {and} and_assign
                       | {caret} caret_assign
                       | {bar} bar_assign
                       ;

conditional_expression   = logical_expression ex_logical_repeat* ;
ex_logical_repeat        = question expression colon logical_or_expression ;
logical_or_expression    = logical_and_expression logical_and_repeat* ;
logical_and_repeat       = bar_bar logical_and_expression ;
logical_and_expression   = equality_expression equality_ex_repeat* ;
equality_ex_repeat       = amp_amp equality_expression ;
equality_expression      = relational_expression relational_repeat* ;
relational_repeat        = equal_or_n_equal relational_repeat;
equal_or_n_equal         = {equal} equal
                          | {notequal} n_equal ;
relational_expression    = unary_expression unary_expression_expression* ;
unary_expression_repeat  = inequality unary_expression ;
inequality               = {less} less_than
                         | {lesseq} less_than_eq
                         | {greater} greater_than
                         | {greatereq} greater_then_eq
                         ;
unary_expression         = {postfix} postfix_expression
                         | {unary} ex unary_expression ;
postfix_expression       = primary_expression function_call* ;
function_call            = left_paren argument_expression_list? right_paren ;
argument_expression_list = assignment_expression argument_expression_list* ;
assignment_expression_repeat = comma assignment_expression;
primary_expression       = {constant} constant
                         | {expression} left_paren expression right_paren
                         | {identifier} identifier
                         | {function} function_expression
                         ;
function_expression      = type identifier? left_paren method_param_list right_paren block colon_colon ;

constant = {integer} integer_literal
        | {boolean} boolean_literal
        | {character} character_literal
        | {string} string_literal
        | {null} null_literal
        ;
