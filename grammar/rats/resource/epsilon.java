package resource;
// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on 2017年1月19日 at 15:14:34.
// Edit at your own risk.
// ===========================================================================

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>epsilon</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class epsilon extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fUB;
    Result fUB$$Star1;
    Result fIdentifier;
    Result fDIGIT;
    Result fW;
    Result fDeclaration;
    Result fFunctionParamList;
    Result fFunctionParamList$$Star1;
    Result fFunctionParam;
    Result fInitDecl;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fBlock;
    Result fBlock$$Star1;
    Result fStatement;
    Result fExpression;
    Result fExpression$$Star1;
    Result fAssignmentExpression;
    Result fConditionalExpression;
    Result fConditionalExpression$$Star1;
    Result fLogicalOrExpression;
    Result fLogicalOrExpression$$Star1;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fLogicalAndExpression;
    Result fLogicalAndExpression$$Star1;
    Result fEqualityExpression;
    Result fEqualityExpression$$Star1;
    Result fRelationalExpression;
    Result fRelationalExpression$$Star1;
    Result fUnaryExpression;
    Result fPrimaryExpression;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class epsilonColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public epsilon(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public epsilon(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new epsilonColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTopLevel(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyResult = pUB(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for v$g$1.
        Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyResult = pEOT(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("File", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.UB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pUB(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fUB) yyColumn.chunk1.fUB = pUB$1(yyStart);
    return yyColumn.chunk1.fUB;
  }

  /** Actually parse epsilon.UB. */
  private Result pUB$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUB$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("UB", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.UB$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUB$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBLOCKCOMMENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLINECOMMENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.UB$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUB$$Star1(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fUB$$Star1) 
      yyColumn.chunk1.fUB$$Star1 = pUB$$Star1$1(yyStart);
    return yyColumn.chunk1.fUB$$Star1;
  }

  /** Actually parse epsilon.UB$$Star1. */
  private Result pUB$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUB$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = pUB$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$5 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$5);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.S.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('\t' <= yyC) && (yyC <= '\n')) ||
          ('\r' == yyC) ||
          (' ' == yyC)) {

        yyValue = GNode.create("S", false);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("S expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.BLOCKCOMMENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBLOCKCOMMENT(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    int             yyPredIndex;
    boolean         yyPredMatched;
    int             yyRepetition1;
    Pair<Character> yyRepValue1;
    Node            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyPredMatched = false;

          yyC = character(yyRepetition1);
          if ('*' == yyC) {
            yyPredIndex = yyRepetition1 + 1;

            yyC = character(yyPredIndex);
            if ('/' == yyC) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;
              char v$el$1 = (char)yyC;

              yyRepetition1 = yyIndex;
              yyRepValue1   = new Pair<Character>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("BLOCKCOMMENT expected", yyStart);
          }
          break;
        }
        { // Start scope for v$g$1.
          Pair<Character> v$g$1 = yyRepValue1.reverse();

          yyC = character(yyRepetition1);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = GNode.create("BLOCKCOMMENT", v$g$1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        } // End scope for v$g$1.
      }
    }

    // Done.
    yyError = yyError.select("BLOCKCOMMENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.LINECOMMENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLINECOMMENT(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    boolean         yyPredMatched;
    int             yyRepetition1;
    Pair<Character> yyRepValue1;
    Node            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyPredMatched = false;

          yyC = character(yyRepetition1);
          if ('\n' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;
              char v$el$1 = (char)yyC;

              yyRepetition1 = yyIndex;
              yyRepValue1   = new Pair<Character>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("LINECOMMENT expected", yyStart);
          }
          break;
        }
        { // Start scope for v$g$1.
          Pair<Character> v$g$1 = yyRepValue1.reverse();

          yyValue = GNode.create("LINECOMMENT", v$g$1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$1.
      }
    }

    // Done.
    yyError = yyError.select("LINECOMMENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.EOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOT(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = GNode.create("EOT", false);

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOT expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIdentifier(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifier) 
      yyColumn.chunk1.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk1.fIdentifier;
  }

  /** Actually parse epsilon.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNAME(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pUB(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("Identifier", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.NAME.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNAME(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pDIGIT(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyPredMatched = false;

      yyPredResult = pKEYWORD(yyStart);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyRepetition1 = yyStart;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pW(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }

        if (yyRepeated1) {
          Pair<Node> v$g$1 = yyRepValue1.reverse();

          yyValue = GNode.create("NAME", v$g$1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }
      } else {
        yyError = yyError.select("NAME expected", yyStart);
      }
    } else {
      yyError = yyError.select("NAME expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.DIGIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDIGIT(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDIGIT) 
      yyColumn.chunk1.fDIGIT = pDIGIT$1(yyStart);
    return yyColumn.chunk1.fDIGIT;
  }

  /** Actually parse epsilon.DIGIT. */
  private Result pDIGIT$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('0' <= yyC) && (yyC <= '9')) {

        yyValue = GNode.create("DIGIT", false);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DIGIT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.W.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pW(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fW) yyColumn.chunk1.fW = pW$1(yyStart);
    return yyColumn.chunk1.fW;
  }

  /** Actually parse epsilon.W. */
  private Result pW$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('$' == yyC) ||
          (('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = GNode.create("W", false);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("W expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.TopLevel.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTopLevel(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pTopLevel$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.create("TopLevel", v$g$1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.TopLevel$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTopLevel$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.KEYWORD.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pKEYWORD(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKEYWORD$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyPredResult = pW(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = GNode.create("KEYWORD", false);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("KEYWORD expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.KEYWORD$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKEYWORD$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt11_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAlt11_1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAlt11_2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pAlt11_3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pAlt11_4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt11_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt11_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = GNode.create("Alt11_0", false);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt11_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt11_1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt11_1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = GNode.create("Alt11_1", false);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("alt11_1 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt11_2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt11_2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyValue = GNode.create("Alt11_2", false);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt11_2 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt11_3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt11_3(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyValue = GNode.create("Alt11_3", false);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt11_3 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt11_4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt11_4(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = GNode.create("Alt11_4", false);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt11_4 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclaration) 
      yyColumn.chunk1.fDeclaration = pDeclaration$1(yyStart);
    return yyColumn.chunk1.fDeclaration;
  }

  /** Actually parse epsilon.Declaration. */
  private Result pDeclaration$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFunctionDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Declaration", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVariableDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Declaration", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.FunctionDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFunctionDeclaration(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pW(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyResult = pUB(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pIdentifier(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Node v$g$1 = yyResult.semanticValue();

                          yyResult = pUB(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyC = character(yyResult.index);
                            if ('(' == yyC) {
                              yyIndex = yyResult.index + 1;

                              yyResult = pUB(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pFunctionParamList(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Node v$g$2 = yyResult.semanticValue();

                                  yyC = character(yyResult.index);
                                  if (')' == yyC) {
                                    yyIndex = yyResult.index + 1;

                                    yyResult = pUB(yyIndex);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyResult = pBlock(yyResult.index);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {
                                        Node v$g$3 = yyResult.semanticValue();

                                        yyValue = GNode.create("FunctionDeclaration", v$g$1, v$g$2, v$g$3);

                                        return yyResult.createValue(yyValue, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      yyError = yyError.select("function declaration expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("function declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.FunctionParamList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFunctionParamList(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFunctionParamList) 
      yyColumn.chunk1.fFunctionParamList = pFunctionParamList$1(yyStart);
    return yyColumn.chunk1.fFunctionParamList;
  }

  /** Actually parse epsilon.FunctionParamList. */
  private Result pFunctionParamList$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFunctionParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pFunctionParamList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("FunctionParamList", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.FunctionParamList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionParamList$$Star1(final int yyStart) 
    throws IOException {

    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFunctionParamList$$Star1) 
      yyColumn.chunk1.fFunctionParamList$$Star1 = pFunctionParamList$$Star1$1(yyStart);
    return yyColumn.chunk1.fFunctionParamList$$Star1;
  }

  /** Actually parse epsilon.FunctionParamList$$Star1. */
  private Result pFunctionParamList$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUB(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pFunctionParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyResult = pFunctionParamList$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Node> v$2 = yyResult.semanticValue();

            yyValue = new Pair<Node>(v$el$1, v$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.FunctionParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFunctionParam(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFunctionParam) 
      yyColumn.chunk1.fFunctionParam = pFunctionParam$1(yyStart);
    return yyColumn.chunk1.fFunctionParam;
  }

  /** Actually parse epsilon.FunctionParam. */
  private Result pFunctionParam$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pUB(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("FunctionParam", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.VariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pVariableDeclaration(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pW(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyResult = pUB(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pVariableList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$1 = yyResult.semanticValue();

                yyC = character(yyResult.index);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pUB(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = GNode.create("VariableDeclaration", v$g$1);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("variable declaration expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("variable declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.VariableList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pVariableList(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyC = character(yyRepetition1);
        if (',' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pInitDecl(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          }
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.create("VariableList", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    yyError = yyError.select("variable list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.InitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pInitDecl(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fInitDecl) 
      yyColumn.chunk1.fInitDecl = pInitDecl$1(yyStart);
    return yyColumn.chunk1.fInitDecl;
  }

  /** Actually parse epsilon.InitDecl. */
  private Result pInitDecl$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyC = character(yyResult.index);
      if ('=' == yyC) {
        yyIndex = yyResult.index + 1;

        yyPredMatched = false;

        yyC = character(yyIndex);
        if ('=' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInitializer(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$2 = yyResult.semanticValue();

              yyResult = pUB(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = GNode.create("InitDecl", v$g$1, v$g$2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        } else {
          yyError = yyError.select("init decl expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("init decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Initializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pInitializer(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Initializer", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBlock(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fBlock) 
      yyColumn.chunk2.fBlock = pBlock$1(yyStart);
    return yyColumn.chunk2.fBlock;
  }

  /** Actually parse epsilon.Block. */
  private Result pBlock$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUB(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlock$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyC = character(yyResult.index);
          if ('}' == yyC) {
            yyIndex = yyResult.index + 1;

            yyResult = pUB(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = GNode.create("Block", false);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.Block$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock$$Star1(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fBlock$$Star1) 
      yyColumn.chunk2.fBlock$$Star1 = pBlock$$Star1$1(yyStart);
    return yyColumn.chunk2.fBlock$$Star1;
  }

  /** Actually parse epsilon.Block$$Star1. */
  private Result pBlock$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt20_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pAlt20_1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt20_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt20_0(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pUB(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("Alt20_0", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt20_1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt20_1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pUB(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("Alt20_1", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStatement(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse epsilon.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pW(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyC = character(yyResult.index);
            if ('(' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pUB(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$2 = yyResult.semanticValue();

                  yyC = character(yyResult.index);
                  if (')' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyResult = pUB(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pBlock(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$g$3 = yyResult.semanticValue();

                        yyC = character(yyResult.index);
                        if ('e' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyC = character(yyIndex);
                          if ('l' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('e' == yyC) {
                                yyIndex = yyIndex + 1;

                                final int yyChoice1 = yyIndex;

                                // Nested alternative 1.

                                yyC = character(yyChoice1);
                                if ('1' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$4 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$4);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 2.

                                yyC = character(yyChoice1);
                                if ('2' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$5 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$5);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 3.

                                yyC = character(yyChoice1);
                                if ('3' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$6 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$6);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 4.

                                yyC = character(yyChoice1);
                                if ('4' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$7 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$7);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 5.

                                yyC = character(yyChoice1);
                                if ('5' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$8 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$8);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 6.

                                yyC = character(yyChoice1);
                                if ('6' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$9 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$9);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 7.

                                yyC = character(yyChoice1);
                                if ('7' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$10 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$10);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 8.

                                yyC = character(yyChoice1);
                                if ('8' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$11 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$11);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 9.

                                yyC = character(yyChoice1);
                                if ('9' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$12 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$12);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 10.

                                yyC = character(yyChoice1);
                                if ('A' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$13 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$13);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 11.

                                yyC = character(yyChoice1);
                                if ('B' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$14 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$14);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 12.

                                yyC = character(yyChoice1);
                                if ('C' == yyC) {
                                  yyIndex = yyChoice1 + 1;

                                  yyResult = pUB(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$15 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$15);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }

                                // Nested alternative 13.

                                yyPredMatched = false;

                                yyPredResult = pW(yyChoice1);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyResult = pUB(yyChoice1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pBlock(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Node v$g$16 = yyResult.semanticValue();

                                      yyValue = GNode.create("Statement", v$g$2, v$g$3, v$g$16);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                } else {
                                  yyError = yyError.select("statement expected", yyStart);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          yyError = yyError.select("statement expected", yyStart);
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pW(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyResult = pUB(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Node v$g$17 = yyResult.semanticValue();

                      yyC = character(yyResult.index);
                      if (';' == yyC) {
                        yyIndex = yyResult.index + 1;

                        yyResult = pUB(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyValue = GNode.create("Statement", v$g$17);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                } else {
                  yyError = yyError.select("statement expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$18 = yyResult.semanticValue();

      yyC = character(yyResult.index);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Statement", v$g$18);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpression) 
      yyColumn.chunk2.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk2.fExpression;
  }

  /** Actually parse epsilon.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Expression", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.Expression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Star1(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpression$$Star1) 
      yyColumn.chunk2.fExpression$$Star1 = pExpression$$Star1$1(yyStart);
    return yyColumn.chunk2.fExpression$$Star1;
  }

  /** Actually parse epsilon.Expression$$Star1. */
  private Result pExpression$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUB(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyResult = pExpression$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Node> v$2 = yyResult.semanticValue();

            yyValue = new Pair<Node>(v$el$1, v$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.AssignmentExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAssignmentExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAssignmentExpression) 
      yyColumn.chunk2.fAssignmentExpression = pAssignmentExpression$1(yyStart);
    return yyColumn.chunk2.fAssignmentExpression;
  }

  /** Actually parse epsilon.AssignmentExpression. */
  private Result pAssignmentExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pUBAssignmentOperator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyResult = pAssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("AssignmentExpression", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("AssignmentExpression", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.UBAssignmentOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pUBAssignmentOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt24_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAlt24_1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAlt24_2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pAlt24_3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pAlt24_4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pAlt24_5(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pAlt24_6(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pAlt24_7(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pAlt24_8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pAlt24_9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pAlt24_10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = pAlt24_11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("UBAssignmentOperator", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_0", false);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("alt24_0 expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("alt24_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_1", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_1 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_2", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_2 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_3(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_3", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_3 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_4(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_4", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_4 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_5.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_5(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_5", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_5 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_6.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_6(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('=' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("Alt24_6", false);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_6 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_7.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_7(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('=' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("Alt24_7", false);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_7 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_8.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_8(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('=' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pUB(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = GNode.create("Alt24_8", false);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_8 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_9.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_9(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_9", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_9 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_10.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_10(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_10", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_10 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt24_11.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt24_11(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt24_11", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt24_11 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.ConstantExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pConstantExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantExpression", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pConditionalExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConditionalExpression) 
      yyColumn.chunk2.fConditionalExpression = pConditionalExpression$1(yyStart);
    return yyColumn.chunk2.fConditionalExpression;
  }

  /** Actually parse epsilon.ConditionalExpression. */
  private Result pConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pConditionalExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.ConditionalExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConditionalExpression$$Star1(final int yyStart) 
    throws IOException {

    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConditionalExpression$$Star1) 
      yyColumn.chunk2.fConditionalExpression$$Star1 = pConditionalExpression$$Star1$1(yyStart);
    return yyColumn.chunk2.fConditionalExpression$$Star1;
  }

  /** Actually parse epsilon.ConditionalExpression$$Star1. */
  private Result pConditionalExpression$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUB(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if (':' == yyC) {
            yyIndex = yyResult.index + 1;

            yyPredMatched = false;

            yyC = character(yyIndex);
            if ('>' == yyC) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyResult = pUB(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pLogicalOrExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pConditionalExpression$$Star1(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Pair<Node> v$2 = yyResult.semanticValue();

                    yyValue = new Pair<Node>(v$el$1, v$2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            } else {
              yyError = yyError.select("conditional expression expected", yyStart);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLogicalOrExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLogicalOrExpression) 
      yyColumn.chunk2.fLogicalOrExpression = pLogicalOrExpression$1(yyStart);
    return yyColumn.chunk2.fLogicalOrExpression;
  }

  /** Actually parse epsilon.LogicalOrExpression. */
  private Result pLogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pLogicalOrExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalOrExpression", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.LogicalOrExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression$$Star1(final int yyStart) 
    throws IOException {

    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLogicalOrExpression$$Star1) 
      yyColumn.chunk2.fLogicalOrExpression$$Star1 = pLogicalOrExpression$$Star1$1(yyStart);
    return yyColumn.chunk2.fLogicalOrExpression$$Star1;
  }

  /** Actually parse epsilon.LogicalOrExpression$$Star1. */
  private Result pLogicalOrExpression$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLogicalAndExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyResult = pLogicalOrExpression$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Node> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Node>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLogicalAndExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLogicalAndExpression) 
      yyColumn.chunk3.fLogicalAndExpression = pLogicalAndExpression$1(yyStart);
    return yyColumn.chunk3.fLogicalAndExpression;
  }

  /** Actually parse epsilon.LogicalAndExpression. */
  private Result pLogicalAndExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pLogicalAndExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalAndExpression", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.LogicalAndExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression$$Star1(final int yyStart) 
    throws IOException {

    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLogicalAndExpression$$Star1) 
      yyColumn.chunk3.fLogicalAndExpression$$Star1 = pLogicalAndExpression$$Star1$1(yyStart);
    return yyColumn.chunk3.fLogicalAndExpression$$Star1;
  }

  /** Actually parse epsilon.LogicalAndExpression$$Star1. */
  private Result pLogicalAndExpression$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEqualityExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyResult = pLogicalAndExpression$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Node> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Node>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEqualityExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fEqualityExpression) 
      yyColumn.chunk3.fEqualityExpression = pEqualityExpression$1(yyStart);
    return yyColumn.chunk3.fEqualityExpression;
  }

  /** Actually parse epsilon.EqualityExpression. */
  private Result pEqualityExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pEqualityExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("EqualityExpression", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.EqualityExpression$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt29_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAlt29_1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.EqualityExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression$$Star1(final int yyStart) 
    throws IOException {

    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fEqualityExpression$$Star1) 
      yyColumn.chunk3.fEqualityExpression$$Star1 = pEqualityExpression$$Star1$1(yyStart);
    return yyColumn.chunk3.fEqualityExpression$$Star1;
  }

  /** Actually parse epsilon.EqualityExpression$$Star1. */
  private Result pEqualityExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEqualityExpression$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRelationalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pEqualityExpression$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt29_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt29_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt29_0", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt29_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt29_1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt29_1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt29_1", false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt29_1 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pRelationalExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fRelationalExpression) 
      yyColumn.chunk3.fRelationalExpression = pRelationalExpression$1(yyStart);
    return yyColumn.chunk3.fRelationalExpression;
  }

  /** Actually parse epsilon.RelationalExpression. */
  private Result pRelationalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pRelationalExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("RelationalExpression", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.RelationalExpression$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt30_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAlt30_1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAlt30_2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pAlt30_3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal epsilon.RelationalExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression$$Star1(final int yyStart) 
    throws IOException {

    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fRelationalExpression$$Star1) 
      yyColumn.chunk3.fRelationalExpression$$Star1 = pRelationalExpression$$Star1$1(yyStart);
    return yyColumn.chunk3.fRelationalExpression$$Star1;
  }

  /** Actually parse epsilon.RelationalExpression$$Star1. */
  private Result pRelationalExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelationalExpression$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pRelationalExpression$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt30_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt30_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt30_0", false);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("alt30_0 expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("alt30_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt30_1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt30_1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyC = character(yyIndex);
        if ('=' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("Alt30_1", false);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("alt30_1 expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt30_1 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt30_2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt30_2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Alt30_2", false);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("alt30_2 expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("alt30_2 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt30_3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt30_3(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyC = character(yyIndex);
        if ('=' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("Alt30_3", false);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("alt30_3 expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt30_3 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pUnaryExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fUnaryExpression) 
      yyColumn.chunk3.fUnaryExpression = pUnaryExpression$1(yyStart);
    return yyColumn.chunk3.fUnaryExpression;
  }

  /** Actually parse epsilon.UnaryExpression. */
  private Result pUnaryExpression$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("UnaryExpression", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyResult = pUB(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pUnaryExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("UnaryExpression", v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("unary expression expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pPostfixExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFunctionCall(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PostfixExpression", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("PostfixExpression", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.FunctionCall.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFunctionCall(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pUBFunctionCall(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.create("FunctionCall", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.UBFunctionCall.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pUBFunctionCall(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUB(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUBArgumentExpressionList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$1 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if (')' == yyC) {
            yyIndex = yyResult.index + 1;

            yyResult = pUB(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = GNode.create("UBFunctionCall", v$g$1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("u b function call expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.UBArgumentExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pUBArgumentExpressionList(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyC = character(yyRepetition1);
        if (',' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pAssignmentExpression(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          }
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.create("UBArgumentExpressionList", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    yyError = yyError.select("u b argument expression list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pPrimaryExpression(final int yyStart) throws IOException {
    epsilonColumn yyColumn = (epsilonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPrimaryExpression) 
      yyColumn.chunk3.fPrimaryExpression = pPrimaryExpression$1(yyStart);
    return yyColumn.chunk3.fPrimaryExpression;
  }

  /** Actually parse epsilon.PrimaryExpression. */
  private Result pPrimaryExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryExpression", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAlt36_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("PrimaryExpression", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pFunctionExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryExpression", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryExpression", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt36_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt36_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUB(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$1 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if (')' == yyC) {
            yyIndex = yyResult.index + 1;

            yyResult = pUB(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = GNode.create("Alt36_0", v$g$1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt36_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.FunctionExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFunctionExpression(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pW(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyResult = pUB(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pIdentifier(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Node v$g$1 = yyResult.semanticValue();

                          yyResult = pUB(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyC = character(yyResult.index);
                            if ('(' == yyC) {
                              yyIndex = yyResult.index + 1;

                              yyResult = pUB(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pFunctionParamList(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Node v$g$2 = yyResult.semanticValue();

                                  yyC = character(yyResult.index);
                                  if (')' == yyC) {
                                    yyIndex = yyResult.index + 1;

                                    yyResult = pUB(yyIndex);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyResult = pBlock(yyResult.index);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {
                                        Node v$g$3 = yyResult.semanticValue();

                                        yyC = character(yyResult.index);
                                        if (':' == yyC) {
                                          yyIndex = yyResult.index + 1;

                                          yyC = character(yyIndex);
                                          if (':' == yyC) {
                                            yyIndex = yyIndex + 1;

                                            yyResult = pUB(yyIndex);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              yyValue = GNode.create("FunctionExpression", v$g$1, v$g$2, v$g$3);

                                              return yyResult.createValue(yyValue, yyError);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      yyError = yyError.select("function expression expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("function expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Constant", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Constant", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Constant", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pNullLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("Constant", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.IntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIntegerLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDECIMAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pUB(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("IntegerLiteral", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.DECIMAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDECIMAL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt40_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("DECIMAL", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = GNode.create("DECIMAL", false);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("DECIMAL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt40_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt40_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('1' <= yyC) && (yyC <= '9')) {

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pDIGIT(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$1.
          Pair<Node> v$g$1 = yyRepValue1.reverse();

          yyValue = GNode.create("Alt40_0", v$g$1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$1.
      }
    }

    // Done.
    yyError = yyError.select("alt40_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBooleanLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlt41_0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("BooleanLiteral", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAlt41_1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = GNode.create("BooleanLiteral", false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt41_0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt41_0(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pW(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyResult = pUB(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = GNode.create("Alt41_0", false);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("alt41_0 expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt41_0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.Alt41_1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAlt41_1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pW(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyResult = pUB(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = GNode.create("Alt41_1", false);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("alt41_1 expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("alt41_1 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStringLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSTRINGUBCONTENT(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$1.
        Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pUB(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("StringLiteral", v$g$1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.STRINGUBCONTENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSTRINGUBCONTENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {
      if (('\n' == yyC) ||
          ('\"' == yyC) ||
          ('\\' == yyC)) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = GNode.create("STRINGUBCONTENT", false);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("STRINGUBCONTENT expected", yyStart);
    }

    // Done.
    yyError = yyError.select("STRINGUBCONTENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal epsilon.NullLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNullLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pW(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyResult = pUB(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = GNode.create("NullLiteral", false);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("null literal expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("null literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

}
